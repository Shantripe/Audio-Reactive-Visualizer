
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Audio Reactive Visuals</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; color: #fff; display: flex; width: 100vw; height: 100vh; }
#canvas-container { flex: 1; position: relative; }
canvas { display: block; width: 100%; height: 100%; }
#ui { width: 320px; min-width: 320px; height: 100vh; background: rgba(10,10,20,0.97); border-left: 1px solid rgba(255,255,255,0.1); padding: 24px; overflow-y: auto; display: flex; flex-direction: column; gap: 24px; }
#ui::-webkit-scrollbar { width: 4px; }
#ui::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
h1 { font-size: 20px; font-weight: 700; background: linear-gradient(135deg,#667eea,#764ba2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.subtitle { font-size: 11px; color: rgba(255,255,255,0.4); margin-top: 4px; }
.section-label { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: rgba(255,255,255,0.5); margin-bottom: 10px; }
#upload-btn { width: 100%; padding: 14px; background: linear-gradient(135deg,#667eea,#764ba2); border: none; border-radius: 8px; color: #fff; font-size: 14px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; }
#upload-btn:hover { opacity: 0.85; }
#file-name { font-size: 12px; color: rgba(255,255,255,0.6); margin-top: 8px; word-break: break-all; min-height: 16px; }
#play-btn { width: 60px; height: 60px; border-radius: 50%; background: linear-gradient(135deg,#667eea,#764ba2); border: none; color: #fff; font-size: 22px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 15px rgba(102,126,234,0.4); }
#play-btn:hover { transform: scale(1.08); box-shadow: 0 6px 20px rgba(102,126,234,0.6); }
#play-btn.playing { background: linear-gradient(135deg,#f093fb,#f5576c); }
.playback-row { display: flex; align-items: center; gap: 14px; }
#time-display { font-size: 15px; font-weight: 500; color: rgba(255,255,255,0.85); }
#seek { width: 100%; height: 5px; border-radius: 3px; background: rgba(255,255,255,0.1); outline: none; -webkit-appearance: none; cursor: pointer; }
#seek::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: linear-gradient(135deg,#667eea,#764ba2); cursor: pointer; }
.mode-btn { width: 100%; padding: 12px 14px; background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; cursor: pointer; text-align: left; transition: all 0.2s; font-size: 13px; font-weight: 600; }
.mode-btn:hover { background: rgba(255,255,255,0.1); transform: translateX(4px); }
.mode-btn.active { background: rgba(102,126,234,0.25); border-color: #667eea; box-shadow: 0 0 16px rgba(102,126,234,0.3); }
.mode-btn small { display: block; font-size: 11px; font-weight: 400; color: rgba(255,255,255,0.45); margin-top: 3px; }
.slider-row { margin-bottom: 16px; }
.slider-row label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 8px; }
.slider-row label span:first-child { color: rgba(255,255,255,0.75); }
.slider-row label span:last-child { color: #667eea; font-weight: 600; }
.slider-row input[type=range] { width: 100%; height: 5px; border-radius: 3px; background: rgba(255,255,255,0.1); outline: none; -webkit-appearance: none; }
.slider-row input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: linear-gradient(135deg,#667eea,#764ba2); cursor: pointer; }
#fps { font-size: 12px; color: rgba(255,255,255,0.3); font-family: monospace; margin-top: auto; }
#hide-ui { position: fixed; top: 16px; right: 336px; width: 36px; height: 36px; border-radius: 50%; background: rgba(10,10,20,0.9); border: 1px solid rgba(255,255,255,0.15); color: #fff; font-size: 16px; cursor: pointer; z-index: 10; display: flex; align-items: center; justify-content: center; }
#hide-ui:hover { background: rgba(102,126,234,0.7); }
#show-ui { display: none; position: fixed; top: 16px; right: 16px; width: 36px; height: 36px; border-radius: 50%; background: rgba(10,10,20,0.9); border: 1px solid rgba(255,255,255,0.15); color: #fff; font-size: 16px; cursor: pointer; z-index: 10; align-items: center; justify-content: center; }
#show-ui:hover { background: rgba(102,126,234,0.7); }
#no-file-msg { font-size: 12px; color: rgba(255,255,255,0.35); text-align: center; padding: 8px; }
</style>
</head>
<body>

<div id="canvas-container">
  <canvas id="c"></canvas>
</div>

<button id="hide-ui" title="Hide UI">âœ•</button>
<button id="show-ui" title="Show UI">â˜°</button>

<div id="ui">
  <div>
    <h1>Audio Reactive Visuals</h1>
    <div class="subtitle">WebGL Â· Three.js Â· Web Audio API</div>
  </div>

  <div>
    <div class="section-label">Audio File</div>
    <button id="upload-btn">ğŸ“ Upload Audio (MP3 / WAV / FLAC)</button>
    <input type="file" id="file-input" accept="audio/*" style="display:none">
    <div id="file-name">No file loaded</div>
  </div>

  <div>
    <div class="section-label">Playback</div>
    <div class="playback-row">
      <button id="play-btn" disabled>â–¶</button>
      <div id="time-display">0:00 / 0:00</div>
    </div>
    <input type="range" id="seek" min="0" max="100" value="0" step="0.1" style="margin-top:12px;width:100%">
    <div id="no-file-msg">Upload a file to start</div>
  </div>

  <div>
    <div class="section-label">Visual Mode</div>
    <div style="display:flex;flex-direction:column;gap:8px">
      <button class="mode-btn active" data-mode="particles">âœ¨ Particle Field <small>15,000 GPU particles with flow field</small></button>
      <button class="mode-btn" data-mode="liquid">ğŸŒŠ Liquid Shader <small>Kaleidoscopic fluid distortion</small></button>
      <button class="mode-btn" data-mode="geometry">ğŸ”· Audio Geometry <small>Deforming 3D shapes</small></button>
      <button class="mode-btn" data-mode="storm">âš¡ Neural Storm <small>Lightning arcs &amp; fog</small></button>
    </div>
  </div>

  <div>
    <div class="section-label">Sensitivity</div>
    <div class="slider-row">
      <label><span>Bass Intensity</span><span id="bass-val">1.0x</span></label>
      <input type="range" id="bass-slider" min="0" max="3" step="0.1" value="1">
    </div>
    <div class="slider-row">
      <label><span>Treble Intensity</span><span id="treble-val">1.0x</span></label>
      <input type="range" id="treble-slider" min="0" max="3" step="0.1" value="1">
    </div>
    <div class="slider-row">
      <label><span>Volume</span><span id="vol-val">100%</span></label>
      <input type="range" id="vol-slider" min="0" max="1" step="0.01" value="1">
    </div>
  </div>

  <div id="fps">60 FPS</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const state = {
  mode: 'particles',
  bassIntensity: 1,
  trebleIntensity: 1,
  playing: false,
  audioReady: false,
  // audio
  audioEl: null,
  audioCtx: null,
  analyser: null,
  gainNode: null,
  // audio data
  bass: 0, mid: 0, treble: 0, energy: 0, beat: 0, spectral: 0.5,
  freqData: null,
  timeData: null,
  // beat
  beatHistory: [], beatValue: 0, lastBeat: 0,
  // smooth prev
  prev: { bass:0, mid:0, treble:0, energy:0 }
};

// â”€â”€â”€ Three.js setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
camera.position.z = 50;

function resize() {
  const w = canvas.parentElement.clientWidth;
  const h = window.innerHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  if (liquidMesh) liquidMesh.material.uniforms.resolution.value.set(w, h);
}
window.addEventListener('resize', resize);

// â”€â”€â”€ Visual Modes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// --- Particles ---
let particlesMesh = null;
const PCOUNT = 12000;
function initParticles() {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(PCOUNT * 3);
  const col = new Float32Array(PCOUNT * 3);
  const vel = new Float32Array(PCOUNT * 3);
  const sz  = new Float32Array(PCOUNT);
  for (let i = 0; i < PCOUNT; i++) {
    const r = Math.random() * 50, t = Math.random()*Math.PI*2, p = Math.random()*Math.PI;
    pos[i*3]   = r*Math.sin(p)*Math.cos(t);
    pos[i*3+1] = r*Math.sin(p)*Math.sin(t);
    pos[i*3+2] = r*Math.cos(p);
    vel[i*3]   = (Math.random()-.5)*.05;
    vel[i*3+1] = (Math.random()-.5)*.05;
    vel[i*3+2] = (Math.random()-.5)*.05;
    col[i*3]=Math.random(); col[i*3+1]=Math.random(); col[i*3+2]=Math.random();
    sz[i] = Math.random()*2+.5;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color',    new THREE.BufferAttribute(col, 3));
  geo.setAttribute('velocity', new THREE.BufferAttribute(vel, 3));
  geo.setAttribute('size',     new THREE.BufferAttribute(sz,  1));
  const mat = new THREE.ShaderMaterial({
    uniforms: { bass:{value:0}, treble:{value:0}, beat:{value:0}, time:{value:0} },
    vertexShader: `
      attribute float size; attribute vec3 velocity;
      uniform float bass, treble, beat, time;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec3 p = position + velocity * time * 0.1;
        p *= 1.0 + bass*0.4 + beat*0.5;
        vec4 mv = modelViewMatrix * vec4(p,1.0);
        float shimmer = 1.0 + treble * sin(time*8.0+position.x)*.4;
        gl_PointSize = size * shimmer * (280.0/-mv.z);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader: `
      varying vec3 vColor;
      uniform float treble;
      void main() {
        vec2 c = gl_PointCoord-.5;
        if(length(c)>.5) discard;
        float a = 1.0-smoothstep(0.,.5,length(c));
        gl_FragColor = vec4(vColor*(1.0+treble*.5), a*.85);
      }`,
    transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true
  });
  particlesMesh = new THREE.Points(geo, mat);
  scene.add(particlesMesh);
}

function updateParticles(delta) {
  if (!particlesMesh) return;
  const m = particlesMesh.material;
  m.uniforms.bass.value   = state.bass;
  m.uniforms.treble.value = state.treble;
  m.uniforms.beat.value   = state.beat;
  m.uniforms.time.value  += delta;
  const pos = particlesMesh.geometry.attributes.position.array;
  const vel = particlesMesh.geometry.attributes.velocity.array;
  const col = particlesMesh.geometry.attributes.color.array;
  const turb = state.mid * 1.5;
  for (let i = 0; i < PCOUNT; i++) {
    const i3 = i*3;
    vel[i3]  += (Math.random()-.5)*turb*.008;
    vel[i3+1]+= (Math.random()-.5)*turb*.008;
    vel[i3+2]+= (Math.random()-.5)*turb*.008;
    pos[i3]  += vel[i3];
    pos[i3+1]+= vel[i3+1];
    pos[i3+2]+= vel[i3+2];
    for(let j=0;j<3;j++) if(Math.abs(pos[i3+j])>58) pos[i3+j]*=-.6;
    // color hue shift
    const h = state.spectral*6, c2=.8, x=c2*(1-Math.abs(h%2-1));
    let r,g,b;
    if(h<1){r=c2;g=x;b=0;}else if(h<2){r=x;g=c2;b=0;}else if(h<3){r=0;g=c2;b=x;}
    else if(h<4){r=0;g=x;b=c2;}else if(h<5){r=x;g=0;b=c2;}else{r=c2;g=0;b=x;}
    col[i3]=r; col[i3+1]=g; col[i3+2]=b;
  }
  particlesMesh.geometry.attributes.position.needsUpdate=true;
  particlesMesh.geometry.attributes.color.needsUpdate=true;
  particlesMesh.rotation.y += delta*.08;
}

// --- Liquid Shader ---
let liquidMesh = null;
function initLiquid() {
  const geo = new THREE.PlaneGeometry(2,2);
  const mat = new THREE.ShaderMaterial({
    uniforms: {
      time:{value:0}, resolution:{value:new THREE.Vector2(800,600)},
      bass:{value:0}, treble:{value:0}, mid:{value:0},
      beat:{value:0}, energy:{value:0}, spectral:{value:.5}
    },
    vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }`,
    fragmentShader:`
      uniform float time,bass,treble,mid,beat,energy,spectral;
      uniform vec2 resolution;
      varying vec2 vUv;
      vec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}
      vec2 mod289(vec2 x){return x-floor(x*(1./289.))*289.;}
      vec3 permute(vec3 x){return mod289(((x*34.)+1.)*x);}
      float snoise(vec2 v){
        const vec4 C=vec4(.211324865,.366025403,-.577350269,.024390244);
        vec2 i=floor(v+dot(v,C.yy));
        vec2 x0=v-i+dot(i,C.xx);
        vec2 i1=x0.x>x0.y?vec2(1,0):vec2(0,1);
        vec4 x12=x0.xyxy+C.xxzz; x12.xy-=i1;
        i=mod289(i);
        vec3 p=permute(permute(i.y+vec3(0,i1.y,1))+i.x+vec3(0,i1.x,1));
        vec3 m=max(.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.);
        m=m*m*m*m;
        vec3 x2=2.*fract(p*.024390244)-1.;
        vec3 h=abs(x2)-.5; vec3 ox=floor(x2+.5); vec3 a0=x2-ox;
        m*=1.79284291-.85373472*(a0*a0+h*h);
        vec3 g; g.x=a0.x*x0.x+h.x*x0.y;
        g.yz=a0.yz*x12.xz+h.yz*x12.yw;
        return 130.*dot(m,g);
      }
      float fbm(vec2 p){
        float v=0.,a=.5,f=1.;
        for(int i=0;i<5;i++){v+=a*snoise(p*f);f*=2.;a*=.5;}
        return v;
      }
      vec2 kaleido(vec2 uv,float seg){
        float angle=atan(uv.y,uv.x);
        float r=length(uv);
        float sa=6.28318/seg;
        angle=mod(angle,sa);
        angle=abs(angle-sa*.5);
        return vec2(cos(angle),sin(angle))*r;
      }
      vec3 hsv(vec3 c){
        vec4 K=vec4(1.,2./3.,1./3.,3.);
        vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);
        return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);
      }
      void main(){
        vec2 uv=(vUv-.5)*2.; uv.x*=resolution.x/resolution.y;
        float amp=.3+bass*1.4;
        float segs=6.+floor(mid*5.);
        vec2 k=kaleido(uv,segs);
        float t=time*.25;
        vec2 d=vec2(fbm(k*2.+t*.5),fbm(k*2.-t*.3))*amp;
        vec2 du=k+d;
        float n1=fbm(du*3.+time*.2);
        float n2=fbm(du*5.-time*.3);
        float n3=fbm(du*7.+time*.15);
        float sharp=2.+treble*4.;
        float pat=pow(abs(n1*n2),sharp)*n3;
        float hue=spectral+time*.08+pat*.3;
        vec3 col=hsv(vec3(hue,.75+energy*.25,.5+pat*.5+energy*.3));
        col+=vec3(1.)*beat*.4;
        float glow=1./(1.+length(uv)*2.);
        col+=glow*bass*vec3(.2,.4,.9);
        float vig=smoothstep(.3,1.,1.-length(uv*.5));
        col*=vig;
        gl_FragColor=vec4(col,1.);
      }`
  });
  liquidMesh = new THREE.Mesh(geo, mat);
  liquidMesh.visible = false;
  scene.add(liquidMesh);
}

function updateLiquid(delta) {
  if (!liquidMesh) return;
  const u = liquidMesh.material.uniforms;
  u.time.value   += delta;
  u.bass.value    = state.bass;
  u.treble.value  = state.treble;
  u.mid.value     = state.mid;
  u.beat.value    = state.beat;
  u.energy.value  = state.energy;
  u.spectral.value= state.spectral;
}

// --- Geometry ---
let geoMesh = null;
function initGeometry() {
  const geo = new THREE.IcosahedronGeometry(14, 5);
  const mat = new THREE.ShaderMaterial({
    uniforms: { time:{value:0}, bass:{value:0}, treble:{value:0}, mid:{value:0}, energy:{value:0}, spectral:{value:.5}, beat:{value:0} },
    vertexShader:`
      uniform float time,bass,treble,mid,energy;
      varying vec3 vNorm; varying vec3 vPos; varying float vDisp;
      vec3 mod289v(vec3 x){return x-floor(x*(1./289.))*289.;}
      vec4 mod289v(vec4 x){return x-floor(x*(1./289.))*289.;}
      vec4 permv(vec4 x){return mod289v(((x*34.)+1.)*x);}
      vec4 taylorInvSqrt(vec4 r){return 1.79284291-0.85373472*r;}
      float snoise3(vec3 v){
        const vec2 C=vec2(1./6.,1./3.);const vec4 D=vec4(0.,.5,1.,2.);
        vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);
        vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.-g;
        vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);
        vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;
        i=mod289v(i);
        vec4 p=permv(permv(permv(i.z+vec4(0,i1.z,i2.z,1))+i.y+vec4(0,i1.y,i2.y,1))+i.x+vec4(0,i1.x,i2.x,1));
        float n_=.142857142857;vec3 ns=n_*D.wyz-D.xzx;
        vec4 j=p-49.*floor(p*ns.z*ns.z);
        vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.*x_);
        vec4 x2_=x_*ns.x+ns.yyyy;vec4 y2_=y_*ns.x+ns.yyyy;
        vec4 h=1.-abs(x2_)-abs(y2_);
        vec4 b0=vec4(x2_.xy,y2_.xy);vec4 b1=vec4(x2_.zw,y2_.zw);
        vec4 s0=floor(b0)*2.+1.;vec4 s1=floor(b1)*2.+1.;vec4 sh=-step(h,vec4(0));
        vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
        vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);
        vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
        p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;
        vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);m=m*m;
        return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
      }
      void main(){
        vNorm=normalize(normalMatrix*normal);vPos=position;
        float expand=1.+bass*.45;
        float d=snoise3(position*.4+time*.4)*treble*2.8+snoise3(position*.8+time*.25)*mid*1.8;
        vDisp=d;
        vec3 np=position*expand+normal*d;
        gl_Position=projectionMatrix*modelViewMatrix*vec4(np,1.);
      }`,
    fragmentShader:`
      uniform float spectral,energy,beat,time;
      varying vec3 vNorm;varying vec3 vPos;varying float vDisp;
      vec3 hsv(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}
      void main(){
        vec3 vd=normalize(cameraPosition-vPos);
        float fr=pow(1.-abs(dot(vd,vNorm)),2.);
        float hue=spectral+vDisp*.08+time*.04;
        vec3 col=hsv(vec3(hue,.85,.5+energy*.5+fr*.4));
        col+=fr*vec3(.4,.7,1.)*energy;
        col+=beat*.25;
        gl_FragColor=vec4(col,1.);
      }`,
    side: THREE.DoubleSide
  });
  geoMesh = new THREE.Mesh(geo, mat);
  geoMesh.visible = false;
  scene.add(geoMesh);
}

function updateGeometry(delta) {
  if (!geoMesh) return;
  const u = geoMesh.material.uniforms;
  u.time.value   += delta;
  u.bass.value    = state.bass;
  u.treble.value  = state.treble;
  u.mid.value     = state.mid;
  u.energy.value  = state.energy;
  u.spectral.value= state.spectral;
  u.beat.value    = state.beat;
  geoMesh.rotation.y += delta*(.18+state.beat*.4);
  geoMesh.rotation.x += delta*(.09+state.energy*.15);
}

// --- Storm ---
let stormGroup = null;
const bolts = [];
function initStorm() {
  stormGroup = new THREE.Group();
  scene.add(stormGroup);
  stormGroup.visible = false;
  // fog plane
  const fogGeo = new THREE.PlaneGeometry(120,120);
  const fogMat = new THREE.ShaderMaterial({
    uniforms:{time:{value:0},bass:{value:0},energy:{value:0},beat:{value:0}},
    vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`,
    fragmentShader:`
      uniform float time,bass,energy,beat;varying vec2 vUv;
      float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
      float noise(vec2 p){vec2 i=floor(p);vec2 f=fract(p);f=f*f*(3.-2.*f);float a=hash(i),b=hash(i+vec2(1,0)),c=hash(i+vec2(0,1)),d=hash(i+vec2(1,1));return mix(mix(a,b,f.x),mix(c,d,f.x),f.y);}
      void main(){
        vec2 uv=vUv*4.;
        float fog=noise(uv+time*.08)*.5+noise(uv*2.-time*.12)*.25+noise(uv*4.+time*.18)*.125;
        fog*=.3+bass*.7;
        vec3 col=vec3(.05,.15,.4)*fog+vec3(.3,.05,.4)*fog*energy;
        col+=vec3(.7,.85,1.)*beat*fog;
        gl_FragColor=vec4(col,fog*.5);
      }`,
    transparent:true,depthWrite:false,blending:THREE.AdditiveBlending
  });
  stormGroup.fogMesh = new THREE.Mesh(fogGeo, fogMat);
  stormGroup.fogMesh.position.z = -25;
  stormGroup.add(stormGroup.fogMesh);
  for(let i=0;i<30;i++) spawnBolt(stormGroup);
}

function spawnBolt(group) {
  const segs = 18;
  const pts = [];
  const sx=(Math.random()-.5)*55,sy=(Math.random()-.5)*55,sz=(Math.random()-.5)*55;
  const ex=(Math.random()-.5)*55,ey=(Math.random()-.5)*55,ez=(Math.random()-.5)*55;
  for(let i=0;i<segs;i++){
    const t=i/(segs-1);
    pts.push(new THREE.Vector3(
      sx+(ex-sx)*t+(i>0&&i<segs-1?(Math.random()-.5)*5:0),
      sy+(ey-sy)*t+(i>0&&i<segs-1?(Math.random()-.5)*5:0),
      sz+(ez-sz)*t+(i>0&&i<segs-1?(Math.random()-.5)*5:0)
    ));
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.ShaderMaterial({
    uniforms:{time:{value:0},treble:{value:0},beat:{value:0},op:{value:Math.random()}},
    vertexShader:`void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`,
    fragmentShader:`uniform float time,treble,beat,op;void main(){float p=sin(time*10.)*0.5+0.5;float a=op*p*(.3+treble*.7+beat);gl_FragColor=vec4(.5+treble*.5,.8,1.,a);}`,
    transparent:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  const line = new THREE.Line(geo, mat);
  line.userData.life = Math.random()*2+1;
  line.userData.age  = 0;
  bolts.push(line);
  group.add(line);
}

function updateStorm(delta) {
  if (!stormGroup) return;
  const f = stormGroup.fogMesh;
  f.material.uniforms.time.value += delta;
  f.material.uniforms.bass.value  = state.bass;
  f.material.uniforms.energy.value= state.energy;
  f.material.uniforms.beat.value  = state.beat;
  f.rotation.z += delta*.08;

  for(let i=bolts.length-1;i>=0;i--){
    const b=bolts[i];
    b.userData.age+=delta;
    b.material.uniforms.time.value+=delta;
    b.material.uniforms.treble.value=state.treble;
    b.material.uniforms.beat.value=state.beat;
    b.rotation.x+=delta*.3; b.rotation.y+=delta*.2;
    if(b.userData.age>b.userData.life){
      stormGroup.remove(b);
      b.geometry.dispose(); b.material.dispose();
      bolts.splice(i,1);
    }
  }
  if((state.beat>.5||state.treble>.6)&&bolts.length<60) spawnBolt(stormGroup);
}

// â”€â”€â”€ Mode switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setMode(mode) {
  state.mode = mode;
  if (particlesMesh) particlesMesh.visible = false;
  if (liquidMesh)    liquidMesh.visible    = false;
  if (geoMesh)       geoMesh.visible       = false;
  if (stormGroup)    stormGroup.visible    = false;
  if (mode==='particles' && particlesMesh) particlesMesh.visible = true;
  if (mode==='liquid'    && liquidMesh)    { liquidMesh.visible = true; }
  if (mode==='geometry'  && geoMesh)       geoMesh.visible = true;
  if (mode==='storm'     && stormGroup)    stormGroup.visible = true;
  // For liquid shader, camera needs to be orthographic-style
  if (mode === 'liquid') {
    camera.position.set(0, 0, 1);
  } else {
    camera.position.set(0, 0, 50);
  }
}

// â”€â”€â”€ Audio Analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function smooth(cur, prev) { return prev*.75 + cur*.25; }

function freqAvg(startHz, endHz) {
  if (!state.analyser || !state.freqData) return 0;
  const nyq = state.audioCtx.sampleRate / 2;
  const n   = state.analyser.frequencyBinCount;
  const s   = Math.floor(startHz/nyq*n);
  const e   = Math.floor(endHz/nyq*n);
  let sum=0, cnt=0;
  for(let i=s;i<=e;i++){ sum+=state.freqData[i]; cnt++; }
  return cnt>0 ? sum/cnt/255 : 0;
}

function updateAudio() {
  if (!state.analyser) return;
  state.analyser.getByteFrequencyData(state.freqData);
  state.analyser.getByteTimeDomainData(state.timeData);

  const rawBass   = freqAvg(20, 150)   * state.bassIntensity;
  const rawMid    = freqAvg(400, 2500);
  const rawTreble = freqAvg(6000, 20000) * state.trebleIntensity;

  // RMS energy
  let rms=0;
  for(let i=0;i<state.timeData.length;i++){ const n=(state.timeData[i]-128)/128; rms+=n*n; }
  rms=Math.sqrt(rms/state.timeData.length);

  // Spectral centroid
  let ws=0,ss=0;
  for(let i=0;i<state.freqData.length;i++){ const m=state.freqData[i]/255; ws+=m*i; ss+=m; }
  state.spectral = ss>0 ? (ws/ss)/state.freqData.length : .5;

  state.bass   = smooth(rawBass,   state.prev.bass);
  state.mid    = smooth(rawMid,    state.prev.mid);
  state.treble = smooth(rawTreble, state.prev.treble);
  state.energy = smooth(rms,       state.prev.energy);
  state.prev.bass=state.bass; state.prev.mid=state.mid;
  state.prev.treble=state.treble; state.prev.energy=state.energy;

  // Beat detection
  state.beatHistory.push(state.energy);
  if(state.beatHistory.length>43) state.beatHistory.shift();
  const avg=state.beatHistory.reduce((a,b)=>a+b,0)/state.beatHistory.length;
  if(state.energy>avg*1.3 && Date.now()-state.lastBeat>100){
    state.beatValue=1; state.lastBeat=Date.now();
  }
  state.beatValue*=.96;
  state.beat=state.beatValue;
}

// â”€â”€â”€ Render loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const clock = new THREE.Clock();
let lastFpsTime=0, frameCount=0;

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const elapsed = clock.elapsedTime;

  updateAudio();

  if(state.mode==='particles') updateParticles(delta);
  if(state.mode==='liquid')    updateLiquid(delta);
  if(state.mode==='geometry')  updateGeometry(delta);
  if(state.mode==='storm')     updateStorm(delta);

  // Camera pulse on beat (not for liquid)
  if (state.mode !== 'liquid') {
    camera.position.z = 50 + state.bass*8 + state.beat*4;
    camera.rotation.z = Math.sin(elapsed*.1)*.015*state.energy;
  }

  renderer.render(scene, camera);

  // FPS
  frameCount++;
  if(elapsed-lastFpsTime>=1){ document.getElementById('fps').textContent=frameCount+' FPS'; frameCount=0; lastFpsTime=elapsed; }

  // Seek bar
  if(state.audioEl && !state.audioEl.paused && state.audioEl.duration) {
    const pct = state.audioEl.currentTime / state.audioEl.duration * 100;
    document.getElementById('seek').value = pct;
    document.getElementById('time-display').textContent = fmt(state.audioEl.currentTime)+' / '+fmt(state.audioEl.duration);
  }
}

function fmt(s){ if(!s||isNaN(s))return'0:00'; return Math.floor(s/60)+':'+(Math.floor(s%60)+'').padStart(2,'0'); }

// â”€â”€â”€ UI Wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('upload-btn').onclick = () => document.getElementById('file-input').click();

document.getElementById('file-input').onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  // Stop old audio
  if (state.audioEl) { state.audioEl.pause(); state.audioEl.src=''; }
  if (state.audioCtx) { state.audioCtx.close(); state.audioCtx=null; state.analyser=null; }
  state.audioReady = false;

  // Create audio element
  state.audioEl = new Audio();
  state.audioEl.src = URL.createObjectURL(file);

  await new Promise(res => state.audioEl.addEventListener('loadedmetadata', res, {once:true}));

  document.getElementById('file-name').textContent = file.name;
  document.getElementById('time-display').textContent = '0:00 / '+fmt(state.audioEl.duration);
  document.getElementById('play-btn').disabled = false;
  document.getElementById('no-file-msg').style.display = 'none';
  state.audioReady = true;
  state.playing = false;
  document.getElementById('play-btn').textContent = 'â–¶';
  document.getElementById('play-btn').classList.remove('playing');
};

document.getElementById('play-btn').onclick = async () => {
  if (!state.audioReady || !state.audioEl) return;

  if (state.playing) {
    // PAUSE
    state.audioEl.pause();
    state.playing = false;
    document.getElementById('play-btn').textContent = 'â–¶';
    document.getElementById('play-btn').classList.remove('playing');
    return;
  }

  // PLAY - create AudioContext HERE inside the click handler
  if (!state.audioCtx) {
    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    state.analyser  = state.audioCtx.createAnalyser();
    state.analyser.fftSize = 2048;
    state.analyser.smoothingTimeConstant = 0.7;
    state.analyser.minDecibels = -90;
    state.analyser.maxDecibels = -10;

    state.gainNode = state.audioCtx.createGain();

    const src = state.audioCtx.createMediaElementSource(state.audioEl);
    src.connect(state.analyser);
    state.analyser.connect(state.gainNode);
    state.gainNode.connect(state.audioCtx.destination);

    state.freqData = new Uint8Array(state.analyser.frequencyBinCount);
    state.timeData = new Uint8Array(state.analyser.frequencyBinCount);
    state.gainNode.gain.value = document.getElementById('vol-slider').value;
  }

  if (state.audioCtx.state === 'suspended') await state.audioCtx.resume();

  await state.audioEl.play();
  state.playing = true;
  document.getElementById('play-btn').textContent = 'â¸';
  document.getElementById('play-btn').classList.add('playing');
};

// Seek
document.getElementById('seek').oninput = (e) => {
  if (state.audioEl && state.audioEl.duration) {
    state.audioEl.currentTime = state.audioEl.duration * e.target.value / 100;
  }
};

// Mode buttons
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.onclick = () => {
    document.querySelectorAll('.mode-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    setMode(btn.dataset.mode);
  };
});

// Sliders
document.getElementById('bass-slider').oninput = e => {
  state.bassIntensity = +e.target.value;
  document.getElementById('bass-val').textContent = (+e.target.value).toFixed(1)+'x';
};
document.getElementById('treble-slider').oninput = e => {
  state.trebleIntensity = +e.target.value;
  document.getElementById('treble-val').textContent = (+e.target.value).toFixed(1)+'x';
};
document.getElementById('vol-slider').oninput = e => {
  document.getElementById('vol-val').textContent = Math.round(e.target.value*100)+'%';
  if (state.gainNode) state.gainNode.gain.value = +e.target.value;
};

// Hide/show UI
document.getElementById('hide-ui').onclick = () => {
  document.getElementById('ui').style.display='none';
  document.getElementById('hide-ui').style.display='none';
  document.getElementById('show-ui').style.display='flex';
  resize();
};
document.getElementById('show-ui').onclick = () => {
  document.getElementById('ui').style.display='flex';
  document.getElementById('hide-ui').style.display='flex';
  document.getElementById('show-ui').style.display='none';
  resize();
};

// Audio ended
document.addEventListener('DOMContentLoaded', () => {});

// â”€â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ï¿½ï¿½â”€â”€â”€â”€â”€
initParticles();
initLiquid();
initGeometry();
initStorm();
setMode('particles');
resize();
animate();
</script>
</body>
</html>
HTMLEOF